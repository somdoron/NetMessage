using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NetMessage.Core.AsyncIO
{
    class StateMachineEvent : IDisposable
    {
        public StateMachineEvent()
        {
            Source = null;
            SourceId = -1;
            Type = -1;
            StateMachine = null;
            Active = false;
        }

        public StateMachine StateMachine { get; set; }

        public int SourceId { get; set; }

        public StateMachine Source { get; set; }

        public int Type { get; set; }

        public bool Active
        {
            get;private
            set;
        }

        public void Activate()
        {
            Active = true;
        }

        public void Process()
        {
            Active = false;
            StateMachine.Feed(SourceId, Type, Source);    
        }

        public void Dispose()
        {
            Source = null;
            SourceId = -1;
            Type = -1;
            StateMachine = null;
            Active = false;
        }
    }

    abstract class StateMachine : IDisposable
    {       
        /// <summary>
        /// Special source for actions. It's negative not to clash with user-defined
        /// sources.
        /// </summary>
        public const int ActionSourceId = -2;

        public const int RootSourceId = -1;

        /// <summary>
        /// Actions generated by fsm object. The values are negative not to clash
        /// with user-defined actions.
        /// </summary>
        public const int StartAction = -2;

        /// <summary>
        /// Actions generated by fsm object. The values are negative not to clash
        /// with user-defined actions.
        /// </summary>
        public const int StopAction = -3;

        private enum State
        {
            Idle =1, Active=2,Stopping = 3
        }

        private State m_state;
        private int m_sourceId;
        private StateMachine m_owner;

        public StateMachine()
        {
            
        }

        public StateMachine(int sourceId, StateMachine owner)
        {
            m_state = State.Idle;
            Context = owner.Context;            
            m_sourceId = sourceId;
            m_owner = owner;
            StateMachineStoppedEvent = new StateMachineEvent();
        }

        public StateMachine(Context context)
        {
            Context = context;
            m_state = State.Idle;
            m_sourceId = RootSourceId;
            m_owner = null;
            StateMachineStoppedEvent = new StateMachineEvent();
        }

        protected internal StateMachineEvent StateMachineStoppedEvent { get; private set; }

        protected abstract void Handle(int sourceId, int type, StateMachine source);

        protected abstract void Shutdown(int sourceId, int type, StateMachine source);

        public virtual void Dispose()
        {
            Debug.Assert(IsStateMachineIdle);
            StateMachineStoppedEvent.Dispose();
        }

        internal Context Context { get; private set; }        

        protected virtual bool IsStateMachineIdle
        {
            get
            {
                return m_state == State.Idle && !StateMachineStoppedEvent.Active;
            }
        }

        protected void StartStateMachine()
        {
            m_state = State.Active;
            Handle(ActionSourceId, StartAction, null);            
        }

        protected void StopStateMachine()
        {
            // If stopping of the state machine was already requested, do nothing.
            if (m_state == State.Active)
            {
                m_state = State.Stopping;
                Shutdown(ActionSourceId, StopAction, null);
            }
        }

        protected void Stopped(int type)
        {
            Debug.Assert(m_state == State.Stopping);

            Raise(StateMachineStoppedEvent, type);
            m_state = State.Idle;
        }

        protected void StoppedNoEvent()
        {
            Debug.Assert(m_state == State.Stopping);
            m_state = State.Idle;
        }

        protected void SwapStateMachineOwner(ref StateMachine owner, ref int sourceId)
        {
            StateMachine oldOwner = m_owner;
            int oldSourceId = m_sourceId;          

            m_sourceId = sourceId;
            m_owner = owner;

            owner = oldOwner;
            sourceId = oldSourceId;
        }

        protected void Action(int type)
        {
            Debug.Assert(type > 0);
            Feed(ActionSourceId, type, null);
        }

        protected void Raise(StateMachineEvent @event, int type)
        {
            @event.StateMachine = m_owner;
            @event.SourceId = m_sourceId;
            @event.Source = this;
            @event.Type = type;
            Context.Raise(@event);
        }

        protected void RaiseTo(StateMachine destination, StateMachineEvent @event, int sourceId,
            int type, StateMachine source)
        {
            @event.StateMachine = destination;
            @event.SourceId = sourceId;
            @event.Source = source;
            @event.Type = type;
            Context.RaiseTo(@event);
        }

        protected internal void Feed(int sourceId, int type, StateMachine source)
        {
            if (m_state != State.Stopping)
            {
                Handle(sourceId, type, source);
            }
            else
            {
                Shutdown(sourceId, type, source);
            }
        }

        protected internal Worker ChooseWorker()
        {
            return Context.ChooseWorker();
        }
    }
}
